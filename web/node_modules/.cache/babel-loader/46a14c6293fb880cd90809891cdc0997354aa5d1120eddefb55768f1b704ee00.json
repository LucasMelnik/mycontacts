{"ast":null,"code":"var _s = $RefreshSig$();\nimport { useEffect, useState, useCallback, useTransition } from 'react';\nimport ContactsService from '../../services/ContactsService';\nimport toast from '../../utils/toast';\nexport default function useHome() {\n  _s();\n  const [contacts, setContacts] = useState([]);\n  const [orderBy, setOrderBy] = useState('asc');\n  const [searchTerm, setSearchTerm] = useState('');\n  const [isLoading, setIsLoading] = useState(true);\n  const [hasError, setHasError] = useState(false);\n  const [isDeleteModalVisible, setIsDeleteModalVisible] = useState(false);\n  const [contactBeingDeleted, setContactBeingDeleted] = useState(null);\n  const [isLoadingDelete, setIsLoadingDelete] = useState(false);\n  const [filteredContacts, setFilteredContacts] = useState([]);\n  const [isPending, startTransition] = useTransition();\n\n  // const filteredContacts = useMemo(() => contacts.filter((contact) => (\n  //   contact.name.toLowerCase().includes(searchTerm.toLowerCase())\n  // )), [contacts, searchTerm]);\n\n  const loadContacts = useCallback(async () => {\n    try {\n      setIsLoading(true);\n      const contactsList = await ContactsService.listContacts(orderBy);\n      setHasError(false);\n      setContacts(contactsList);\n      setFilteredContacts(contactsList);\n    } catch {\n      setHasError(true);\n      setContacts([]);\n    } finally {\n      setIsLoading(false);\n    }\n  }, [orderBy]);\n  useEffect(() => {\n    loadContacts();\n  }, [loadContacts]);\n  const handleToggleOrderBy = useCallback(() => {\n    setOrderBy(prevState => prevState === 'asc' ? 'desc' : 'asc');\n  });\n  function handleChengeSearchTerm(event) {\n    const {\n      value\n    } = event.target;\n    setSearchTerm(value);\n    startTransition(() => {\n      setFilteredContacts(contacts.filter(contact => contact.name.toLowerCase().includes(value.toLowerCase())));\n    });\n  }\n  function handleTryAgain() {\n    loadContacts();\n  }\n  function handleDeleteContact(contact) {\n    setContactBeingDeleted(contact);\n    setIsDeleteModalVisible(true);\n  }\n  function handleCloeseDeleteModal() {\n    setIsDeleteModalVisible(false);\n  }\n  async function handleConfirmDeleteFunciton() {\n    try {\n      setIsLoadingDelete(true);\n      await ContactsService.deleteContact(contactBeingDeleted.id);\n      setContacts(prevState => prevState.filter(contact => contact.id !== contactBeingDeleted.id));\n      handleCloeseDeleteModal();\n      toast({\n        type: 'success',\n        text: 'Contato deletado com sucesso!'\n      });\n    } catch {\n      toast({\n        type: 'danger',\n        text: 'Ocorreu um erro ao deletar o contato!'\n      });\n    } finally {\n      setIsLoadingDelete(false);\n    }\n  }\n  return {\n    isLoading,\n    isLoadingDelete,\n    isDeleteModalVisible,\n    contactBeingDeleted,\n    handleCloeseDeleteModal,\n    handleConfirmDeleteFunciton,\n    contacts,\n    searchTerm,\n    handleChengeSearchTerm,\n    hasError,\n    handleTryAgain,\n    filteredContacts,\n    orderBy,\n    handleToggleOrderBy,\n    handleDeleteContact,\n    isPending\n  };\n}\n_s(useHome, \"mnz/efCKC+X7jSCiH+caV2wS9iw=\", false, function () {\n  return [useTransition];\n});","map":{"version":3,"names":["useEffect","useState","useCallback","useTransition","ContactsService","toast","useHome","_s","contacts","setContacts","orderBy","setOrderBy","searchTerm","setSearchTerm","isLoading","setIsLoading","hasError","setHasError","isDeleteModalVisible","setIsDeleteModalVisible","contactBeingDeleted","setContactBeingDeleted","isLoadingDelete","setIsLoadingDelete","filteredContacts","setFilteredContacts","isPending","startTransition","loadContacts","contactsList","listContacts","handleToggleOrderBy","prevState","handleChengeSearchTerm","event","value","target","filter","contact","name","toLowerCase","includes","handleTryAgain","handleDeleteContact","handleCloeseDeleteModal","handleConfirmDeleteFunciton","deleteContact","id","type","text"],"sources":["/home/melnik/dev/jstack/mycontacts/web/src/pages/Home/useHome.js"],"sourcesContent":["import {\n  useEffect, useState, useCallback, useTransition,\n} from 'react';\n\nimport ContactsService from '../../services/ContactsService';\n\nimport toast from '../../utils/toast';\n\nexport default function useHome() {\n  const [contacts, setContacts] = useState([]);\n  const [orderBy, setOrderBy] = useState('asc');\n  const [searchTerm, setSearchTerm] = useState('');\n  const [isLoading, setIsLoading] = useState(true);\n  const [hasError, setHasError] = useState(false);\n  const [isDeleteModalVisible, setIsDeleteModalVisible] = useState(false);\n  const [contactBeingDeleted, setContactBeingDeleted] = useState(null);\n  const [isLoadingDelete, setIsLoadingDelete] = useState(false);\n  const [filteredContacts, setFilteredContacts] = useState([]);\n\n  const [isPending, startTransition] = useTransition();\n\n  // const filteredContacts = useMemo(() => contacts.filter((contact) => (\n  //   contact.name.toLowerCase().includes(searchTerm.toLowerCase())\n  // )), [contacts, searchTerm]);\n\n  const loadContacts = useCallback(async () => {\n    try {\n      setIsLoading(true);\n\n      const contactsList = await ContactsService.listContacts(orderBy);\n\n      setHasError(false);\n      setContacts(contactsList);\n      setFilteredContacts(contactsList);\n    } catch {\n      setHasError(true);\n      setContacts([]);\n    } finally {\n      setIsLoading(false);\n    }\n  }, [orderBy]);\n\n  useEffect(() => {\n    loadContacts();\n  }, [loadContacts]);\n\n  const handleToggleOrderBy = useCallback(() => {\n    setOrderBy(\n      (prevState) => (prevState === 'asc' ? 'desc' : 'asc'),\n    );\n  });\n\n  function handleChengeSearchTerm(event) {\n    const { value } = event.target;\n\n    setSearchTerm(value);\n\n    startTransition(() => {\n      setFilteredContacts(contacts.filter((contact) => (\n        contact.name.toLowerCase().includes(value.toLowerCase())\n      )));\n    });\n  }\n\n  function handleTryAgain() {\n    loadContacts();\n  }\n\n  function handleDeleteContact(contact) {\n    setContactBeingDeleted(contact);\n    setIsDeleteModalVisible(true);\n  }\n\n  function handleCloeseDeleteModal() {\n    setIsDeleteModalVisible(false);\n  }\n\n  async function handleConfirmDeleteFunciton() {\n    try {\n      setIsLoadingDelete(true);\n\n      await ContactsService.deleteContact(contactBeingDeleted.id);\n\n      setContacts((prevState) => prevState.filter(\n        (contact) => contact.id !== contactBeingDeleted.id,\n      ));\n\n      handleCloeseDeleteModal();\n\n      toast({\n        type: 'success',\n        text: 'Contato deletado com sucesso!',\n      });\n    } catch {\n      toast({\n        type: 'danger',\n        text: 'Ocorreu um erro ao deletar o contato!',\n      });\n    } finally {\n      setIsLoadingDelete(false);\n    }\n  }\n\n  return {\n    isLoading,\n    isLoadingDelete,\n    isDeleteModalVisible,\n    contactBeingDeleted,\n    handleCloeseDeleteModal,\n    handleConfirmDeleteFunciton,\n    contacts,\n    searchTerm,\n    handleChengeSearchTerm,\n    hasError,\n    handleTryAgain,\n    filteredContacts,\n    orderBy,\n    handleToggleOrderBy,\n    handleDeleteContact,\n    isPending,\n  };\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}